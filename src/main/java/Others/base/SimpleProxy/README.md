## 代理
代理是基本的设计模式之一。

是为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。

将额外的操作从“实际”对象中分离到不同的地方，特别是希望能够容易的做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就显得很有用。

设计模式的关键就是封装修改-因此需要修改事务以证明这种模式的正确性。如，当希望跟踪Dog中的方法调用，或度量这些调用的开销，这些代码肯定不希望将其合并到应用中的代码，此时代理可以很容易的添加或移除他们。

通俗说，代理就是对象需要一些附加或不同的操作时，使用第三方对象操作原对象以及处理这些操作，从而达到不直接修改原对象的目的的一种设计模式。

静态代理是在编译时就将接口、实现类、代理类全部写出来，但若是需要很多代理，就需要每一次都这样写一遍，这就可能导致时间与资源的浪费。
此时可以使用动态代理来代替静态代理。

### 静态代理的实现 （SimpleProxyDemo）
接口类 Animal

具体实现类 Dog

代理类 SimpleProxy

测试代理类 SimpleProxyDemo

## 动态代理
动态代理可以动态地创建代理并动态地处理对所代理方法的调用。

在动态代理上所做的所有调用都会被重定向到单一的调用处理器上。

该调用处理器的工作是揭示调用的类型并确定相应的对策。

### JDK动态代理的实现（DynamicProxyDemo）

通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要得到：
    
    1. 一个类加载器（你通常可以从已经被加载的对象获取其类加载器，然后传递给它，如此处的Animal.class.getClassLoader()）
    2. 一个你希望该代理类实现的接口列表（不是类或抽象类）,如 new Class[]{Animal.class}
    3. InvocationHandler接口的一个实现，如DynamicProxyHandler

动态代理可以将所有调用重定向到调用处理器。

通常会向调用处理器的构造器传递一个“实际”对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发。

invoke()方法中传递进来了代理对象，以防使用时需要区分请求的来源，但在许多情况下并不关心这一点。

在invoke()内部，在代理调用方法时，对接口的调用将被重定向为对代理的调用,因此要格外当心。

通常，执行被代理的操作，然后使用Method.invoke()将请求转发给被代对象，并传入必需的参数。
初看起来可能有些受限，就像只能执行泛化操作一样。
但可以通过传递其他的参数，来过滤某些方法的调用。

###  CGLIB动态代理(CGLibDemo)

JDK动态代理: 只能代理实现了接口的类,没有实现接口的类不能实现JDK动态代理。 

Cglib代理: 针对类来实现代理,对指定目标产生一个子类 通过方法拦截技术拦截所有父类方法的调用。 

在实现内部，CGLIB库使用了ASM这一个轻量但高性能的字节码操作框架来转化字节码，产生新类。

#### CGLIB实现方式
 1.首先定义业务类，无需实现接口（当然，实现接口也可以，不影响的）
 
 具体实现类 DogCGlib
 
 2.实现 MethodInterceptor方法代理接口，创建代理类
 
 代理类:CGlibProxy
 
 3.创建业务类和代理类对象，然后通过  代理类对象.getInstance(业务类对象)  返回一个动态代理类对象（它是业务类的子类，可以用业务类引用指向它）。最后通过动态代理类对象进行方法调用。
 
 测试代理类:CGLIBDemo