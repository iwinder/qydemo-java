## 数组

### 特点

#### 数组与其他种类的容器
数组与其他种类的容器之间的区别有三方面：**效率、类型和保存基本类型的能力**。

在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。
- 数组是一个简单的线性序列，这使得元素访问非常快速。
- 付出的代价是数组对象的大小被固定，并且在其生命周期中不可改变。

数组之所以优于泛型之前的同期，就是因为可以创建一个数组去持有某种具体类型。

- 在泛型之前，其他的容器在处理对象时，都将他们视为没有任何具体类型，即将这些对象当做Javav中根类的根类Object处理。
- 有了泛型后，容器可以指定并检查它们所持有对象的类型，并且有了自动包装机制，容器看起来还能够持有基本类型。

随着自动包装机制的出现，容器已经可以与数组几乎一样方便的用于基本类型中了。

**数组硕果仅存的优点就是效率**。然而，如果要解决更一般化的问题，数组可能会受到过多的限制，因此在这些情形下还是会使用容器。

无论什么类型的数组，数组标识符只是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。
可以作为数组初始化语法的一部分隐式地创建此对象，或者用new表达式显式地创建。
只读成员length是数组对象的一部分(事实上，这是唯一一个可以访问的字段)，表示此数组可以存储多少元素。
“[]”语法是访问数组对象的唯一的方式。
#### 对象数组和基本类型数组
对象数组和基本类型数组在使用上几乎是相同的，唯一的区别就是对象数组保存的是引用，基本类型数组直接保存基本类型的值。

多维数组中构成矩阵的每个向量都可以具有任意的长度（这被称为粗糙数组）。
### 数组与泛型
通常，数组与泛型不能很好的结合。不能实例化具有参数化类型的数组。
- 擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。
- 但可以参数化数组本身。

使用参数化方法而不使用参数化类的方便之处在于：

- 不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且可以将其自定义为静态的。
- 当然，不能总是选择使用参数化方法而不是参数化类，但应该成为首选。

- 泛型容器总是比泛型类数据更好的选择。
- 一般而言，会发现泛型在类或方法的边界处很有效，而在类或方法的内部，擦除通常会使泛型变得不适用。如，不能创建泛型数组。

### Arrays实用功能
java.util类库中的Arrays类，有一套用于数组的static实用方法。其中有六个基本方法：
- Arrays.fill()可以填充整个数组。或者只填充数组的某个区域。但只能用单一的数值来调用。
- equals()比较两个数组是否相等（deepEquals()用于多维数组）。
- sort()用于对数组排序。
- binarySearch()用于在已经排序的数组中查找元素。
- toString()产生数组的String表示。
- hashCode()产生数组的散列码

这些方法对各种基本类型和Object类做了重载。此外，Arrays.asList()接收任意的序列或数组作为其参数，并将其转变为List容器。

#### 复制数组-System.arraycopy
标准类库提供的System.arraycopy()，用它复制数组比用for循环快很多。其针对所有类做了重载。

需要的参数有：源数组，表示从源数组中的什么位置开始复制的偏移量，表示从目标数组的什么位置开始复制的偏移量，需要复制的元素个数。
对数组的任意越界操作都会导致异常。

基本类型和对象数组都可以复制。

如果复制对象数组，只是复制了对象的引用，而不是对象本身的拷贝，即浅复制（shallow copy,亦称为浅拷贝）。

不会自动包装盒自动拆包，两个数组必须具有相同的确切类型。

#### 数组的比较
equals(),数组相等的条件：
- 元素的个数必须相等。
- 对应位置的元素也相等

可以通过对每个元素使用equals()作比较来判断，对于基本类型，需要使用基本类型的包装器类的equals()。如，对于int类型需要使用Integer,equals()作比较;

####  数组元素的比较
java有两种方式提供比较功能。

- 方案一：
一种是实现java.lang.Comparable接口，使类具有“天生”的比较能力。

- 方案二：
若没有实现Comparable接口或者不喜欢原有的，可以创建一个实现了Comparator接口的单独的类。这是策略模式的一个应用实例。
一般不需要实现里面的equals()方法，除非有特殊功能需求。

Collections类包含一个reverseOrder()方法，可以产生一个Comparator,可以反转自然的排序顺序，这很容易应用于CompType.
